pragma solidity ^0.5.0;

contract TeacherRate {
	// teachers have unique ID, generated upon creation
	// A name, provided upon creation
	// and an array of ratings to be averaged
	struct teacher {
		uint id;
		bytes32 f_name;
		bytes32 l_name;
		uint[] teacherRatings;
	}

	teacher[] teachers; // array of all teachers

	constructor() public {
		_createTeacher("Ron", "Swanson"); // 0
		_createTeacher("Robin", "Williams"); // 1
		_createTeacher("Reese", "Witherspoon"); // 2
		_createTeacher("Dwight", "Schrute"); // 3
		_createTeacher("Betty", "White"); // 4
	}

	// pushes a new instance of teacher struct to array of all teachers
	// ID is autogenerated and ratings are an empty dynamic array
	function _createTeacher (bytes32 _fname, bytes32 _lname) public {
		uint _id = _generateID();
		teachers.push(teacher({
			id: _id,
			f_name: _fname,
			l_name: _lname,
			teacherRatings: new uint[](0)
			})) -1;
	}

	// Generates a new id sequentially 
	function _generateID () view internal returns(uint) {
		if (teachers.length < 1) {
			return 0;
		}
		else {
			return teachers.length;
		}
	}

	// ', string memory _review' removed param
	function _submitRating (uint _teacherID, uint _rating) public payable {
		if (_rating > 5) { // rating must be less than 5
			revert();
		}
		else {
			teachers[_teacherID].teacherRatings.push(_rating) -1;
		}
	}
	
			
	// returns the average of all ratings of teacher with given ID
	function _getTeacherRatings(uint _teacherID) view public returns (uint) {
		uint avg = 0;
		if (teachers[_teacherID].teacherRatings.length >= 1) {
			uint len = teachers[_teacherID].teacherRatings.length;
			for(uint i = 0; i <  len; i++){
				avg += teachers[_teacherID].teacherRatings[i];
			}
			avg = avg / len;
		}
		return avg; 
	}
	
	// returns array of teacher Ids rather than array of structs,
	// which isn't currently supported by solidity
	function _getTeacherIds() view public returns (uint[] memory){
		uint[] memory _Ids;
		for(uint i; i < teachers.length; i++){
			_Ids[i] = teachers[i].id;
		}
		return _Ids;
	}

	//returns first, last of teacher with given id
	function _getTeacherName (uint _id) view public returns(bytes32, bytes32) {
		return (teachers[_id].f_name, teachers[_id].l_name);
	}
	
}